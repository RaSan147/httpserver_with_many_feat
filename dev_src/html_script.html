<script>

const r_li = ${PY_LINK_LIST};
const f_li = ${PY_FILE_LIST};
const s_li = ${PY_FILE_SIZE};




class ContextMenu {
	constructor() {
		this.old_name = null;
	}
	async on_result(self) {
		var data = false;
		if (self.status == 200) {
			data = JSON.parse(self.responseText);
		}
		popup_msg.close()
		await tools.sleep(300)
		if (data) {
			popup_msg.createPopup(data["head"], data["body"]);
			if (data["script"]) {
				var script = document.createElement("script");
				script.innerHTML = data["script"];
				document.body.appendChild(script);
			}
		} else {
			popup_msg.createPopup("Failed", "Server didn't respond<br>response: " + self.status);
		}
		popup_msg.open_popup()
	}
	menu_click(action, link, more_data = null) {
		var that = this
		popup_msg.close()

		var url = ".?"+action;
		var xhr = new XMLHttpRequest();
		xhr.open("POST", url);
		xhr.onreadystatechange = function() {
			if (this.readyState === 4) {
				that.on_result(this)
			}
		};
		var formData = new FormData();
		formData.append("post-type", action);
		formData.append("post-uid", 123456); // TODO: add uid
		formData.append("name", link);
		formData.append("data", more_data)
		xhr.send(formData);
	}
	rename_data() {
		var new_name = byId("rename").value;

		this.menu_click("rename", this.old_name, new_name)
		// popup_msg.createPopup("Done!", "New name: "+new_name)
		// popup_msg.open_popup()
	}
	rename(link, name) {
		popup_msg.close()
		popup_msg.createPopup("Rename",
			"Enter new name: <input id='rename' type='text'><br><br><div class='pagination center' onclick='context_menu.rename_data()'>Change!</div>"
			);
		popup_msg.open_popup()
		this.old_name = link;
		byId("rename").value = name;
		byId("rename").focus()
	}
	show_menus(file, name, type) {
		var that = this;
		var menu = createElement("div")

		var new_tab = createElement("div")
			new_tab.innerText = "‚ÜóÔ∏è" + " New tab"
			new_tab.className = "disable_selection popup-btn menu_options"
			new_tab.onclick = function() {
				window.open(file, '_blank');
				popup_msg.close()
			}
			menu.appendChild(new_tab)
		if (type != "folder") {
			var download = createElement("div")
			download.innerText = "üì•" + " Download"
			download.className = "disable_selection popup-btn menu_options"
			download.onclick = function() {
				tools.download(file, name);
				popup_msg.close()
			}
			menu.appendChild(download)
			var copy_url = ""
		}
		if (type == "folder") {
			var dl_zip = createElement("div")
			dl_zip.innerText = "üì¶" + " Download as Zip"
			dl_zip.className = "disable_selection popup-btn menu_options"
			dl_zip.onclick = function() {
				popup_msg.close()
				window.open(go_link('czip', file), '_blank');
				// czip = "Create Zip"
			}
			menu.appendChild(dl_zip)
		}

		var copy = createElement("div")
		copy.innerText = "üìã" + " Copy link"
		copy.className = "disable_selection popup-btn menu_options"
		copy.onclick = async function(ev) {
			popup_msg.close()

			let success = await tools.copy_2(ev, tools.full_path(file))
			if(success){
				toaster.toast("Link Copied!")
			}else{
				toaster.toast("Failed to copy!")
			}
		}
		menu.appendChild(copy)

		var rename = createElement("div")
		rename.innerText = "‚úèÔ∏è" + " Rename"
		rename.className = "disable_selection popup-btn menu_options"
		rename.onclick = function() {
			that.rename(file, name)
		}
		menu.appendChild(rename)
		var del = createElement("div")
		del.innerText = "üóëÔ∏è" + " Delete"
		del.className = "disable_selection popup-btn menu_options"
		var xxx = 'F'
		if (type == "folder") {
			xxx = 'D'
		}
		del.onclick = function() {
			that.menu_click('del-f', file);
		};
		
		menu.appendChild(del)
		var del_P = createElement("div")
		del_P.innerText = "üî•" + " Delete permanently"
		del_P.className = "disable_selection popup-btn menu_options"


		del_P.onclick = () => {
			r_u_sure({y:()=>{
				that.menu_click('del-p', file);
			}, head:"Are you sure?", body:"This can't be undone!!!", y_msg:"Continue", n_msg:"Cancel"})
		}
		menu.appendChild(del_P)
		var property = createElement("div")
		property.innerText = "üìÖ" + " Properties"
		property.className = "disable_selection popup-btn menu_options"
		property.onclick = function() {
			that.menu_click('info', file);
		};
		menu.appendChild(property)
		popup_msg.createPopup("Menu", menu)
		popup_msg.open_popup()
	}
	create_folder() {
		let folder_name = byId('folder-name').value;
		this.menu_click('new_folder', folder_name)
	}
}
var context_menu = new ContextMenu()
//context_menu.show_menus("next", "video")

function show_response(url, add_reload_btn = true) {
	var xhr = new XMLHttpRequest();
	xhr.onreadystatechange = function() {
		if (xhr.readyState == XMLHttpRequest.DONE) {
			let msg = xhr.responseText;
			if (add_reload_btn) {
				msg = msg + "<br><br><div class='pagination' onclick='window.location.reload()'>RefreshüîÑÔ∏è</div>";
			}
			popup_msg.close()
			popup_msg.createPopup("Result", msg);
			popup_msg.open_popup();
		}
	}
	xhr.open('GET', url, true);
	xhr.send(null);
}

function reload() {
	show_response("/?reload");
}

function run_recyle(url) {
	return function() {
		show_response(url);
	}
}

function insertAfter(newNode, existingNode) {
	existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling);
}

function fmbytes(B) {
	'Return the given bytes as a file manager friendly KB, MB, GB, or TB string'
	const KB = 1024,
	MB = (KB ** 2),
	GB = (KB ** 3),
	TB = (KB ** 4)

	var unit="byte", val=B;

	if (B>1){
		unit="bytes"
		val = B}
	if (B/KB>1){
		val = (B/KB)
		unit="KB"}
	if (B/MB>1){
		val = (B/MB)
		unit="MB"}
	if (B/GB>1){
		val = (B/GB)
		unit="GB"}
	if (B/TB>1){
		val = (B/TB)
		unit="TB"}

	val = val.toFixed(2)

	return `${val} ${unit}`
}



tools.del_child("linkss");
const folder_li = createElement('div');
const file_li = createElement("div")
for (let i = 0; i < r_li.length; i++) {
	// time to customize the links according to their formats
	var folder = false
	let type = null;
	let r = r_li[i];
	let r_ = r.slice(1);
	let name = f_li[i];

	let item = createElement('div');
	item.classList.add("dir_item")


	let link = createElement('a');// both icon and title, display:flex
	link.href = r_;
	link.title = name;

	link.classList.add('all_link');
	link.classList.add("disable_selection")
	let l_icon = createElement("span")
	// this will go inside "link" 1st
	l_icon.classList.add("link_icon")

	let l_box = createElement("span")
	// this will go inside "link" 2nd
	l_box.classList.add("link_name")


	if (r.startsWith('d')) {
		// add DOWNLOAD FOLDER OPTION in it
		// TODO: add download folder option by zipping it
		// currently only shows folder size and its contents
		type = "folder"
		folder = true
		l_icon.innerHTML = "üìÇ".toHtmlEntities();
		l_box.classList.add('link');
	}
	if (r.startsWith('v')) {
		// if its a video, add play button at the end
		// that will redirect to the video player
		// clicking main link will download the video instead
		type = 'video';
		l_icon.innerHTML = 'üé•'.toHtmlEntities();
		link.href = go_link("vid", r_)
		l_box.classList.add('vid');
	}
	if (r.startsWith('i')) {
		type = 'image'
		l_icon.innerHTML = 'üåâ'.toHtmlEntities();
		l_box.classList.add('file');
	}
	if (r.startsWith('f')) {
		type = 'file'
		l_icon.innerHTML = 'üìÑ'.toHtmlEntities();
		l_box.classList.add('file');
	}
	if (r.startsWith('h')) {
		type = 'html'
		l_icon.innerHTML = 'üîó'.toHtmlEntities();
		l_box.classList.add('html');
	}

	link.appendChild(l_icon)

	l_box.innerText = " " + name;

	if(s_li[i]){
		l_box.appendChild(createElement("br"))

		let s = createElement("span")
		s.className= "link_size"
		s.innerText = s_li[i]
		l_box.appendChild(s)
	}
	link.appendChild(l_box)


	link.oncontextmenu = function(ev) {
		ev.preventDefault()
		
		context_menu.show_menus(r_, name, type);
		return false;
	}

	item.appendChild(link);
	//item.appendChild(context);
	// recycling option for the files and folder
	// files and folders are handled differently
	var xxx = "F"
	if (r.startsWith('d')) {
		xxx = "D";
	}


	var hrr = createElement("hr")
	item.appendChild(hrr);
	if (folder) {
		folder_li.appendChild(item);
	} else {
		file_li.appendChild(item)
	}
}
var dir_container = byId("js-content_list")
dir_container.appendChild(folder_li)
dir_container.appendChild(file_li)


class ProgressBars {
	constructor() {
		this.last_index = 1
		this.bars = {}
		/* Data Structure 
		{index: {
			type: "upload", or "zip"
			status: "waiting" | "running" | "done" | "error"
			form_id: 0, // UploadManager.uploaders[form_id]
			persent: 0,
			source_dir: "", // location from where the file is being uploaded
			status_text: "", // status text
			status_color: "", // status color for the text
		}, ...} */
		this.bar_elements = {}

		this.island_bar = byId("progress-island")
		this.island_up_text = byId("progress-uploads")
		this.island_up_count = byId("progress-uploads-count")
		
		this.island_zip_text = byId("progress-zips")
		this.island_zip_count = byId("progress-zips-count")
	}

	new(type, id, source_dir) {
		const that = this;
		const index = this.last_index;
		this.last_index += 1;

		let bar = {
			type: type,
			form_id: id,
			percent: 0,
			source_dir: source_dir,
			status_text: "",
			status_color: "",
		}
		this.bars[index] = bar
		this.bar_elements[index] = null // will be set later


		let bar_element = createElement("div")
		bar_element.className = "progress_bar"
		bar_element.id = "progress_bar_" + index

		let bar_head = createElement("div")
		bar_head.className = "progress_bar_heading"
		
		let bar_head_text = createElement("div")
		bar_head_text.className ="progress_bar_heading_text"
		if(type=="upload"){
			bar_head_text.innerText = "Uploading"
		} else if(type=="zip"){
			bar_head_text.innerText = "Zipping"
		}
		bar_head_text.style.float ="left"
		bar_head.appendChild(bar_head_text)

		let bar_status = createElement("div")
		bar_status.className = "progress_bar_status"
		bar_status.innerText = "0%"
		bar_status.style.float = "right" 
		bar_head.appendChild(bar_status)
		bar_element.appendChild(bar_head)
		
		
		let status_label = createElement("span")
		status_label.style.font_size = ".6em"
		status_label.innerText = "Status: "
		bar_element.appendChild(status_label)

		let bar_status_text = createElement("span")
		bar_status_text.className = "progress_bar_status_text"
		bar_status_text.innerText = "Waiting"
		bar_element.appendChild(bar_status_text)

		let bar_progress = createElement("progress")
		bar_progress.className = "progress_bar_progress"
		bar_progress.value = 0
		bar_progress.max = 100
		bar_element.appendChild(bar_progress)

		bar_element.appendChild(createElement("br"))

		let bar_cancel = createElement("span")
		bar_cancel.className = "progress_bar_cancel"
		bar_cancel.innerHTML = "&#9888; Delete Task"
		bar_cancel.onclick = function(e){
			e.stopPropagation() // stop the click event from propagating to the bar element
			if (type == "upload") {
				upload_man.remove(id)
			} else if (type == "zip") {
				zip_man.cancel(id)
			}

			that.remove(index)
		}
		bar_element.appendChild(bar_cancel)

		bar_element.onclick = ()=>{
			if(type=="upload") {
				upload_man.show(id)
			} else if(type=="zip") {
				zip_man.show(id)
			}
		}


		this.bar_elements[index] = bar_element

		return index

	}

	
	update_island() {
		let up_count = 0
		let up_done_count = 0
		let zip_count = 0
		let zip_done_count = 0
		for (let index in this.bars) {
			let bar = this.bars[index]
			if (bar.type == "upload") {
				up_count += 1;
				if (bar.status == "done") {
					up_done_count += 1;
				}
			} else if (bar.type == "zip") {
				zip_count += 1;
				if (bar.status == "done") {
					zip_done_count += 1;
				}
			}
		}
		
		this.island_bar.style.display = "block"
		if (!(up_count||zip_count)){
			this.island_bar.style.display = "None"
			return
		}

		
		if (up_count){
			this.island_up_text.style.display = "block"
			this.island_up_count.innerText = "(" + up_done_count + '/' + up_count + ')'
		} else {
			this.island_up_text.style.display = "none"
		}
		
		if (zip_count){
			this.island_zip_text.style.display = "block"
			this.island_zip_count.innerText = "(" + zip_done_count + '/' + zip_count + ')'
		} else {
			this.island_zip_text.style.display = "none"
		} 
	}


	update(index, datas={}) {
		let bar = this.bars[index]
		for (let key in datas) {
			bar[key] = datas[key]
		}
		this.update_bar(index)
	}

	update_bar(index){
		let bar = this.bars[index]
		let bar_element = this.bar_elements[index]
		let type = bar.type
		
		

		let bar_head_text = bar_element.getElementsByClassName("progress_bar_heading_text")[0]
		if(type=="upload"){
			bar_head_text.innerText = "Uploading"
		} else if(type=="zip"){
			bar_head_text.innerText = "Zipping"
		}

		let bar_status = bar_element.getElementsByClassName("progress_bar_status")[0]
		bar_status.className = "progress_bar_status"
		bar_status.innerText = bar.percent + "%"

		let bar_status_text = bar_element.getElementsByClassName("progress_bar_status_text")[0]
		bar_status_text.innerText = bar.status_text || "Waiting"
		bar_status_text.style.color = bar.status_color || "white"
		
		
		
		let bar_progress = bar_element.getElementsByClassName("progress_bar_progress")[0]
		bar_progress.value = bar.percent
		
		this.update_island()
	}

	show_list() {
		let list = createElement("div")
		list.className = "progress_bar_list"

		let heading = createElement("h3")
		heading.innerText = "Do not close this tab while tasks are running"
		list.appendChild(heading)
		list.appendChild(createElement("hr"))


		for (let index in this.bars) {
			let bar = this.bars[index]
			let bar_element = this.bar_elements[index]
			list.appendChild(bar_element)
		}
		
		popup_msg.createPopup("Running Tasks", list)

		popup_msg.open_popup()
	}

	remove(index) {
		// check if the index exists
		if (!(index in this.bars)) {
			return // to avoid recursion
		}

		delete this.bars[index] // remove the id 1st
		let bar_element = this.bar_elements[index]
		bar_element.remove() // remove the element from the DOM
		delete this.bar_elements[index] // remove the element from the list

		toaster.toast("Task removed")
		this.update_island()
	}
}

var progress_bars = new ProgressBars()
progress_bars.update_island()


class UploadManager {
	constructor() {
		this.last_index = 1
		this.uploaders = {}
		this.requests = {}
		this.status = {}
		/* Data Structure
		{index: form_element, ...} 
		*/
	}

	new() {
		//selecting all required elements
		const that = this;
		const index = this.last_index;
		this.last_index += 1;

		let Form = createElement("form")
		Form.id = "uploader-" + index
		Form.className = "jsonly"
		Form.method = "post"
		Form.action = "?upload"
		Form.enctype = "multipart/form-data"

		let center = createElement("center")
		// centering the form


		let post_type = createElement("input")
		post_type.type = "hidden";
		post_type.name = "post-type";
		post_type.value = "upload";
		center.appendChild(post_type)

		let post_uid = createElement("input")
		post_uid.type = "hidden";
		post_uid.name = "post-uid";
		post_uid.value = "12345";
		center.appendChild(post_uid)

		let pass_header = createElement("span")
		pass_header.className = "upload-pass";
		pass_header.innerText = "Password:  ";
		center.appendChild(pass_header)

		let pass_input = createElement("input")
		pass_input.type = "password";
		pass_input.name = "password";
		pass_input.placeholder = "Password";
		pass_input.label = "Password";
		pass_input.className = "upload-pass-box";
		center.appendChild(pass_input)

		
		let up_files = createElement("input")
		up_files.type = "file";
		up_files.name = "file";
		up_files.multiple = true
		up_files.hidden = true;
		up_files.onchange = (e)=>{
			// USING THE BROWSE BUTTON
			let f = e.target.files; // this.files = [file1, file2,...];
			addFiles(f);
		};
		center.appendChild(up_files)


		center.appendChild(createElement("br"))
		center.appendChild(createElement("br"))

		let uploader_box = createElement("div")
		uploader_box.className = "upload-box";

			let uploader_dragArea = createElement("div")
			uploader_dragArea.className = "drag-area";
			uploader_dragArea.id = "drag-area";

			let up_icon = createElement("div")
			up_icon.className = "drag-icon";
			up_icon.innerText = "‚¨ÜÔ∏è";
			uploader_dragArea.appendChild(up_icon)

			let up_text = createElement("header")
			up_text.innerText = "Drag & Drop to Upload File";
			uploader_dragArea.appendChild(up_text)

			let or_text = createElement("span")
			or_text.innerText = "OR"
			uploader_dragArea.appendChild(or_text)

			let up_button = createElement("button")
			up_button.type = "button";
			up_button.innerText = "Browse File";
			up_button.className = "drag-browse";
			up_button.onclick = (e)=>{
				e.preventDefault();
				up_files.click(); //if user click on the button then the input also clicked
			}
			uploader_dragArea.appendChild(up_button)

			uploader_dragArea.ondragover = (event)=>{
				event.preventDefault(); //preventing from default behaviour
				uploader_dragArea.classList.add("active");
				up_text.innerText = "Release to Upload File";
			};
			
			//If user leave dragged File from DropArea
			uploader_dragArea.ondragleave = ()=>{
				uploader_dragArea.classList.remove("active");
				up_text.innerText = "Drag & Drop to Upload File";
			};
			
			//If user drop File on DropArea
			uploader_dragArea.ondrop = (event)=>{
				event.preventDefault(); //preventing from default behaviour
				//getting user select file and [0] this means if user select multiple files then we'll select only the first one
				addFiles(event.dataTransfer.files);
				// uploader_showFiles(); //calling function
			};

		uploader_box.appendChild(uploader_dragArea)
		center.appendChild(uploader_box)
		
		let uploader_file_display_title = createElement("h2")
		uploader_file_display_title.innerText = "Selected Files"
		uploader_file_display_title.className = "has-selected-files";
		uploader_file_display_title.style.display = "none";
		center.appendChild(uploader_file_display_title)

		Form.appendChild(center)

		let uploader_file_display = createElement("div")
		uploader_file_display.className = "drag-file-list";
		Form.appendChild(uploader_file_display)

		Form.appendChild(createElement("br"))
		let center2 = createElement("center")
		let submit_button = createElement("button")
		submit_button.type = "submit";
		submit_button.innerText = "‚ûæ Upload";
		submit_button.className = "drag-browse upload-button";

		center2.appendChild(submit_button)
		
		center2.appendChild(createElement("br"))
		center2.appendChild(createElement("br"))
		
		let upload_pop_status_label = createElement("span")
		upload_pop_status_label.innerText = "Status: ";
		let upload_pop_status = createElement("span")
		upload_pop_status.className = "upload-pop-status";
		upload_pop_status.innerText = "Waiting";
		upload_pop_status_label.appendChild(upload_pop_status)
		upload_pop_status_label.style.display = "none";
		center2.appendChild(upload_pop_status_label)
		
		Form.appendChild(center2)

		var prog_id = null;
		var request = null;
		Form["prog_id"] = null; // This is used to update the progress bar

		Form.onsubmit = (e) => {
			e.preventDefault()

			if(that.status[index]){
				that.cancel(index)
				show_status("Upload cancelled")
				return
			}

			that.status[index] = true; // The user is uploading

			request = request || new XMLHttpRequest()
			that.requests[index] = request
			that.uploaders[index] = Form; // Save the form for later use
			// Unless the user is uploading, this won't be saved

			if(selected_files.files.length == 0){
				toaster.toast("No files selected")
				return
			}

			submit_button.innerText = "‚èπÔ∏è Cancel";

			popup_msg.close()
		
			up_files.files = selected_files.files // Assign the updates list
		
		
			const formData = new FormData(e.target)
		
			prog_id = prog_id || progress_bars.new('upload', index, window.location.href) // Create a new progress bar if not already created
			Form.prog_id = prog_id // Save the progress bar id for later use



			var prog = 0, 
			msg = "",
			color = "green"
			status = "waiting"

			
			progress_bars.update(prog_id, {
						"status_text": "Waiting",
						"status_color": color,
						"status": "waiting",
						"percent": 0})

		
			// const filenames = formData.getAll('files').map(v => v.name).join(', ')

			request.open(e.target.method, e.target.action)
			request.timeout = 3600000;
			request.onreadystatechange = () => {
				if (request.readyState === XMLHttpRequest.DONE) {
					msg = `${request.status}: ${request.statusText}`
					status = "error"
					color = "red"
					prog = 0
					if (request.status === 401){
						msg = 'Incorrect password';
					} else if (request.status == 503) {
						msg = 'Upload is disabled'
					} else if (request.status === 0) {
						msg = 'Connection failed (Possible cause: Incorrect password or Upload disabled)'
					} else if (request.status === 204 || request.status === 200) {
						msg = 'Success'
						color = "green"
						prog = 100
						status = "done"
					}

					
					progress_bars.update(prog_id, {
						"status_text": msg,
						"status_color": color,
						"status": status,
						"percent": prog})
						
					submit_button.innerText = "‚ûæ Re-upload";
					if (!that.status[index]){
						return// needs to check this.status[index] because the user might have cancelled the upload but its still called. On cancel already a toast is shown
					}
					show_status(msg)

					if (status === "error") { 
						msg = "Upload Failed"
					} else {
						msg = "Upload Complete"
					}
					toaster.toast(msg, 3000, color)

					that.status[index] = false
					
				}
			}
			request.upload.onprogress = e => {
				prog = Math.floor(100*e.loaded/e.total)
				if(e.loaded === e.total){
					msg ='Saving...'
					show_status(msg)
				}else{
					msg = `Progress`
					show_status(msg + " "+prog + "%")
				}
				
				
				progress_bars.update(prog_id, {
						"status_text": msg,
						"status_color": "green",
						"status": "running",
						"percent": prog})
			}
			request.send(formData)
		}


		let selected_files = new DataTransfer(); //this is a global variable and we'll use it inside multiple functions
		
		function show_status(msg, hide=false){
			if(hide){
				upload_pop_status_label.style.display = "none"
				return
			}
			upload_pop_status_label.style.display = "block"
			upload_pop_status.innerText = msg
		}

		function uploader_exist(file) {
			//check if file is already selected or not
			for (let i = 0; i < selected_files.files.length; i++) {
				if (selected_files.files[i].name == file.name) {
					return i+1; // 0 is false, so we add 1 to make it true
				}
			}
			return false;
		}
		
		function addFiles(files) {
			var exist = false;
			for (let i = 0; i < files.length; i++) {
				exist = uploader_exist(files[i])
		
				if (exist) { //if file already selected, remove that and replace with new one, because, when uploading last file will remain in host server, so we need to replace it with new one
					toaster.toast("File already selected");
					selected_files.items.remove(exist-1);
				}
				selected_files.items.add(files[i]);
			}
			log("selected "+ selected_files.items.length+ " files");
			uploader_showFiles();
		}
		
		
		
		
		
		//If user Drag File Over DropArea
		
		
		function uploader_removeFileFromFileList(index) {
			let dt = new DataTransfer()
			// const input = byId('files')
			// const { files } = input
		
			for (let i = 0; i < selected_files.files.length; i++) {
				let file = selected_files.files[i]
				if (index !== i)
					dt.items.add(file) // here you exclude the file. thus removing it.
			}
		
			selected_files = dt
			// uploader_input.files = dt // Assign the updates list
			uploader_showFiles()
		}
		
		function uploader_showFiles() {
			tools.del_child(uploader_file_display)
			
			if(selected_files.files.length){
				uploader_file_display_title.style.display = "block"
			} else {
				uploader_file_display_title.style.display = "none"
			}
			for (let i = 0; i <selected_files.files.length; i++) {
				uploader_showFile(selected_files.files[i], i);
			}
		}
		
		
		function uploader_showFile(file, index){
			let filename = file.name;
			let size = fmbytes(file.size);
		
			let item = createElement("table");
			item.className = "upload-file-item";
			
			let fname = createElement("td");
			fname.className = "ufname";
			fname.innerText = filename;
			item.appendChild(fname);

			let fsize = createElement("td");
			fsize.className = "ufsize";
			let fsize_text = createElement("span");
			fsize_text.innerText = size;
			fsize.appendChild(fsize_text);
			item.appendChild(fsize);

			let fremove = createElement("td");
			fremove.className = "ufremove";
			let fremove_icon = createElement("span");
			fremove_icon.innerHTML = "&times;";
			fremove_icon.onclick = function(){
				uploader_removeFileFromFileList(index)
			}
			fremove.appendChild(fremove_icon);
			item.appendChild(fremove);
		
			uploader_file_display.appendChild(item);
		
		}
		


		return Form;

	
	}

	up_stat(form, stat=null) {
		if(stat===null){
			return form.getAttribute("uploading");
		}
		form.setAttribute("uploading", stat);
	}

	show(index){
		let form = this.uploaders[index];
		popup_msg.createPopup("Upload Files", form);
		popup_msg.show();
	}

	cancel(index, remove=false){
		let request = this.requests[index];
		let form = this.uploaders[index];
		let prog_id = form.prog_id;
		
		if(form){
			form.querySelector(".upload-button").innerText = "‚ûæ Upload";
		}
		progress_bars.update(prog_id, {
			"status_text": "Upload Canceled",
			"status_color": "red",
			"status": "error",
			"percent": 0})
			

		if(this.status[index]){
			this.status[index] = false;
			if(request){
				request.abort();
			}
			if(!remove) toaster.toast("Upload Canceled");

			return true;
		}
			
		return false;
	}

	remove(index){
		this.cancel(index, true); //cancel the upload (true to make sure it doesn't show toast)
		let form = this.uploaders[index];
		let prog_id = form.prog_id;
		if (prog_id){
			progress_bars.remove(prog_id);
		}
		this.uploaders[index].remove(); //remove the form from DOM
		delete this.uploaders[index]; //remove the form from uploaders array
		delete this.requests[index]; //remove the request from requests array
	}

}

const upload_man = new UploadManager();


class FileManager {
	constructor() {
	}

	show_more_menu(){
		const that = this;
		let menu = createElement("div")

		let sort_by = createElement("div")
		sort_by.innerText = "Sort By"
		sort_by.className = "disable_selection popup-btn menu_options"
		sort_by.onclick = function(){
			that.Show_sort_by()
		}
		menu.appendChild(sort_by)

		let new_folder = createElement("div")
		new_folder.innerText = "New Folder"
		new_folder.onclick = function(){
			that.Show_folder_maker()
		}
		new_folder.className = "disable_selection popup-btn menu_options"
		menu.appendChild(new_folder)

		let upload = createElement("div")
		upload.innerText = "Upload Files"
		upload.onclick = function(){
			that.Show_upload_files()
		}

		upload.className = "disable_selection popup-btn menu_options"
		menu.appendChild(upload)

		popup_msg.createPopup("Options", menu)

		popup_msg.open_popup()
	}


	Show_folder_maker() {
		popup_msg.createPopup("Create Folder",
			"Enter folder name: <input id='folder-name' type='text'><br><br><div class='pagination center' onclick='context_menu.create_folder()'>Create</div>"
			);
		popup_msg.open_popup();
	}

	Show_upload_files() {
		let form = upload_man.new()
		popup_msg.createPopup("Upload Files", form);
		popup_msg.open_popup();
	}



}

const fm = new FileManager();


</script>





<a href="./?admin" class='pagination'>Admin center</a>


<p>pyroBox UI v4 - I ‚ù§Ô∏è emoji!</p>

</body>

</html>
